---
phase: 03-device-tree-kernel
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - installers/rk3588/src/main.go
autonomous: true

must_haves:
  truths:
    - "Installer recognizes nanopi-m6 as valid board option"
    - "Installer copies correct DTB for NanoPi M6 (rk3588s-nanopi-m6.dtb)"
    - "Installer writes vendor U-Boot binaries (idbloader.img + uboot.img) at correct offsets"
  artifacts:
    - path: "installers/rk3588/src/main.go"
      provides: "NanoPi M6 board support in Talos installer"
      contains: "nanopi-m6"
  key_links:
    - from: "installers/rk3588/src/main.go"
      to: "arm64/dtb/rockchip/rk3588s-nanopi-m6.dtb"
      via: "ChipsetName function returns rk3588s"
      pattern: "case.*nanopi-m6.*rk3588s"
    - from: "installers/rk3588/src/main.go"
      to: "arm64/u-boot/nanopi-m6/"
      via: "Install function file path"
      pattern: "nanopi-m6.*idbloader|uboot"
---

<objective>
Update the RK3588 installer to support NanoPi M6 board

Purpose: The Talos installer must know how to flash U-Boot and copy the DTB for NanoPi M6. Unlike Rock 5A/5B which use single u-boot-rockchip.bin, NanoPi M6 requires vendor U-Boot with two files (idbloader.img + uboot.img) at specific offsets.

Output: Modified installer that handles NanoPi M6's unique flash layout and DTB path.
</objective>

<execution_context>
@/Users/johnsonhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/johnsonhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-device-tree-kernel/03-CONTEXT.md
@.planning/phases/02-bootloader/02-09-SUMMARY.md

# Key existing files
@installers/rk3588/src/main.go
@artifacts/u-boot/nanopi-m6/pkg.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NanoPi M6 to ChipsetName function</name>
  <files>installers/rk3588/src/main.go</files>
  <action>
Update the ChipsetName function to recognize nanopi-m6 board:

```go
func ChipsetName(o rk3588ExtraOpts) string {
    if o.Chipset != "" {
        return o.Chipset
    }
    switch o.Board {
    case "rock-5a":
        return "rk3588s"
    case "rock-5b":
        return "rk3588"
    case "nanopi-m6":  // ADD THIS CASE
        return "rk3588s"
    }
    return ""
}
```

This ensures the DTB path is correctly constructed as:
`rockchip/rk3588s-nanopi-m6.dtb`
  </action>
  <verify>
Read main.go and confirm nanopi-m6 case exists in ChipsetName switch
  </verify>
  <done>
ChipsetName returns "rk3588s" for nanopi-m6 board
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Install function for vendor U-Boot flash layout</name>
  <files>installers/rk3588/src/main.go</files>
  <action>
The current Install function assumes a single u-boot-rockchip.bin file. NanoPi M6 requires:
- idbloader.img at sector 64 (offset 0x8000 = 32KB)
- uboot.img at sector 16384 (offset 0x800000 = 8MB)

Modify the Install function to handle board-specific flash layouts:

1. Add constants for NanoPi M6 offsets:
```go
const (
    ubootOffset     int64 = 512 * 64      // Standard offset for u-boot-rockchip.bin
    idbloaderOffset int64 = 512 * 64      // idbloader.img offset (same as standard)
    ubootImgOffset  int64 = 512 * 16384   // uboot.img offset (8MB)
)
```

2. In the Install function, add board-specific logic BEFORE the existing u-boot write:
```go
// Check for NanoPi M6 which uses vendor U-Boot format
if options.ExtraOptions.Board == "nanopi-m6" {
    // Write idbloader.img at sector 64
    idbloader, err := os.ReadFile(filepath.Join(options.ArtifactsPath,
        fmt.Sprintf("arm64/u-boot/%s/idbloader.img", options.ExtraOptions.Board)))
    if err != nil {
        return fmt.Errorf("reading idbloader: %w", err)
    }
    if _, err = f.WriteAt(idbloader, idbloaderOffset); err != nil {
        return fmt.Errorf("writing idbloader: %w", err)
    }

    // Write uboot.img at sector 16384
    ubootImg, err := os.ReadFile(filepath.Join(options.ArtifactsPath,
        fmt.Sprintf("arm64/u-boot/%s/uboot.img", options.ExtraOptions.Board)))
    if err != nil {
        return fmt.Errorf("reading uboot.img: %w", err)
    }
    if _, err = f.WriteAt(ubootImg, ubootImgOffset); err != nil {
        return fmt.Errorf("writing uboot.img: %w", err)
    }
} else {
    // Standard boards use u-boot-rockchip.bin
    uboot, err := os.ReadFile(filepath.Join(options.ArtifactsPath,
        fmt.Sprintf("arm64/u-boot/%s/u-boot-rockchip.bin", options.ExtraOptions.Board)))
    if err != nil {
        return fmt.Errorf("reading u-boot: %w", err)
    }
    if _, err = f.WriteAt(uboot, ubootOffset); err != nil {
        return fmt.Errorf("writing u-boot: %w", err)
    }
}
```

3. Keep the existing DTB copy logic unchanged (it already uses ChipsetName correctly)

IMPORTANT: Maintain existing code style and error handling patterns.
  </action>
  <verify>
1. Read main.go and verify:
   - Constants for offsets are defined
   - Board-specific conditional exists for nanopi-m6
   - idbloader.img and uboot.img paths are correct
   - Error handling follows existing patterns
2. Run `go build` in installers/rk3588/src/ to verify syntax
  </verify>
  <done>
Install function handles nanopi-m6 vendor U-Boot format with two files at correct offsets
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify installer compiles</name>
  <files>installers/rk3588/src/main.go</files>
  <action>
Verify the modified installer compiles without errors:

```bash
cd /Users/johnsonhuynh/Documents/GitHub/nanopi-m6/installers/rk3588/src
go build -o /dev/null .
```

If build fails:
1. Check for syntax errors
2. Verify import statements are complete
3. Fix any type mismatches

Note: The installer binary is built as part of the full image build. This just verifies our Go code is syntactically correct.
  </action>
  <verify>
`go build` completes without errors
  </verify>
  <done>
Installer code compiles successfully with NanoPi M6 support
  </done>
</task>

</tasks>

<verification>
- ChipsetName handles nanopi-m6 board
- Install function has board-specific logic for vendor U-Boot
- Offset constants match Phase 2 findings (sector 64, sector 16384)
- Go code compiles without errors
- Follows existing code style and error handling patterns
</verification>

<success_criteria>
1. installers/rk3588/src/main.go compiles with `go build`
2. nanopi-m6 case added to ChipsetName
3. Install function writes idbloader.img and uboot.img for nanopi-m6
4. DTB path correctly uses rk3588s chipset prefix
</success_criteria>

<output>
After completion, create `.planning/phases/03-device-tree-kernel/03-02-SUMMARY.md`
</output>
