# Phase 1: Environment Setup - Research

**Researched:** 2026-02-02
**Domain:** Development environment, build pipeline, flash workflow for Talos Linux SBC overlay
**Confidence:** HIGH

## Summary

Phase 1 establishes the development environment for building Talos Linux SBC overlays targeting the NanoPi M6. The primary workflow involves local builds on Apple Silicon Mac using Docker buildx for ARM64 artifact generation, with GitHub Actions CI for release validation and publishing. Build outputs go to Docker Hub (per user decision), with flashable images written to SD cards using standard tools (dd or balenaEtcher).

The Siderolabs build ecosystem (bldr, kres) provides the foundation. The milas/talos-sbc-rk3588 repository serves as the base project, offering a working RK3588 overlay that can be forked and extended. Build caching via Docker layer caching (local) and registry cache (CI) provides optimal iteration speed. Since the user decided against UART initially, boot verification relies on HDMI output, network ping, and LED indicators -- this is higher risk but workable for Phase 1.

**Primary recommendation:** Fork milas/talos-sbc-rk3588, configure Docker buildx for ARM64 on Apple Silicon, establish SD card flash workflow with dd, and verify builds via HDMI/network before investing in UART hardware.

## Standard Stack

The established tools for Talos SBC overlay development and environment setup:

### Core

| Tool | Version | Purpose | Why Standard |
|------|---------|---------|--------------|
| **Docker Desktop** | 4.x+ | Container runtime with buildx | Bundled ARM64 emulation via QEMU, native on Apple Silicon |
| **Docker buildx** | Built-in | Multi-platform builds | Native ARM64 on M-series Macs, no QEMU overhead for arm64 |
| **bldr** | v0.3.1 | Package builder | Siderolabs standard for overlay/extension builds, uses BuildKit |
| **kres** | latest | Build config generator | Auto-generates Makefile, CI configs from .kres.yaml |
| **Make** | 4.x+ | Build orchestration | Primary interface via kres-generated Makefile |
| **Git** | 2.x+ | Version control | Fork management, version tagging |

### Supporting

| Tool | Version | Purpose | When to Use |
|------|---------|---------|-------------|
| **balenaEtcher** | 1.18+ | SD card flashing | GUI option for writing images, validates writes |
| **dd** | System | SD card flashing | CLI option, faster with rdisk on macOS |
| **crane** | Latest | Container registry operations | Pushing/copying container images |
| **gh** | 2.x+ | GitHub CLI | Release management, PR workflows |
| **jq** | 1.6+ | JSON processing | Parsing build outputs, version info |

### Container Registries

| Registry | Purpose | Authentication |
|----------|---------|----------------|
| **Docker Hub** | Overlay image hosting (user decision) | DOCKER_USERNAME + DOCKER_PASSWORD (token) |
| **ghcr.io** | Base images, build tools | GITHUB_TOKEN (auto in Actions) |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Docker Desktop | Colima/Podman | Works but less tested with bldr ecosystem |
| dd | Raspberry Pi Imager | Pi Imager doesn't support raw images well |
| balenaEtcher | Apple Configurator | AC is more complex, less portable |

**Installation (macOS):**
```bash
# Docker Desktop - download from docker.com or:
brew install --cask docker

# CLI tools
brew install gh jq crane

# balenaEtcher (optional GUI flasher)
brew install --cask balenaetcher
```

## Architecture Patterns

### Recommended Project Structure

```
nanopi-m6/
├── .github/
│   └── workflows/
│       └── ci.yaml              # GitHub Actions CI (generated by kres)
├── .planning/                   # Planning docs (this project)
├── _out/                        # Build outputs (gitignored)
│   ├── artifacts/               # Build intermediates
│   └── images/                  # Flashable images
├── artifacts/                   # Firmware, U-Boot, DTB definitions
│   ├── arm-trusted-firmware-rk3588/
│   ├── rkbin/
│   └── nanopi-m6/
│       └── u-boot/
├── installers/                  # Go installer binaries
│   └── nanopi-m6/
├── profiles/                    # Board profiles (disk image params)
│   └── nanopi-m6/
├── internal/
│   └── base/                    # Shared build toolchain
├── hack/                        # Dev scripts, patches
├── .kres.yaml                   # kres build configuration
├── Pkgfile                      # bldr package definitions
├── Makefile                     # Generated by kres
└── go.work                      # Go workspace
```

### Pattern 1: Local Development Workflow

**What:** Build and test locally on Apple Silicon, push releases via CI
**When to use:** Daily development iteration

```bash
# Build overlay locally (ARM64 native on M-series Mac)
make local-talos-sbc-rk3588-mainline DEST=_out

# Generate flashable image (requires Talos imager)
docker run --rm -t -v $PWD/_out:/out --privileged \
  ghcr.io/siderolabs/imager:v1.10.9 \
  metal --arch arm64 \
  --overlay-name=nanopi-m6 \
  --overlay-image=docker.io/[username]/nanopi-m6:latest

# Flash to SD card
diskutil unmountDisk /dev/disk2
sudo dd if=_out/metal-arm64.raw of=/dev/rdisk2 bs=1m status=progress
```

### Pattern 2: CI Release Workflow

**What:** GitHub Actions builds and publishes on tag push
**When to use:** Milestone releases, validation builds

```yaml
# Triggered by: git tag v1.10.0-nanopi-m6.1 && git push --tags
# CI performs:
# 1. Build overlay image
# 2. Push to Docker Hub
# 3. Generate flashable images
# 4. Upload to GitHub Releases
```

### Pattern 3: SD Card Swap Testing

**What:** Flash, swap SD card, power cycle, verify boot
**When to use:** Every build iteration without UART

```
1. Build image on Mac
2. Eject SD card from NanoPi M6 (power off first)
3. Insert SD card into Mac reader
4. Flash image with dd or balenaEtcher
5. Eject from Mac, insert into NanoPi M6
6. Power on, verify via HDMI/network/LED
7. If boot fails, repeat from step 1 with fixes
```

### Anti-Patterns to Avoid

- **Building without ARM64 support:** Ensure Docker Desktop has ARM64 enabled (Settings > Features in development > Use Rosetta is OFF for native builds)
- **Flashing without unmounting:** Always unmount SD card before dd, or corruption may occur
- **Using /dev/disk instead of /dev/rdisk on macOS:** rdisk is 20x faster for raw IO
- **Pushing broken images to registry:** Test locally before pushing; broken images poison cache

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Multi-platform Docker builds | Custom build scripts | Docker buildx with QEMU | Handles platform selection, caching, manifest lists automatically |
| Build configuration | Manual Makefiles | kres + .kres.yaml | Regenerates all build scaffolding, keeps CI in sync |
| Package building | Shell scripts | bldr + Pkgfile | Handles dependencies, caching, reproducibility |
| SD card flashing | Custom dd wrapper | balenaEtcher or raw dd | Validation, progress, error handling |
| Container registry auth | Inline credentials | docker/login-action | Secure token handling, logout cleanup |
| Release asset upload | curl to GitHub API | gh release create | Handles checksums, descriptions, asset management |

**Key insight:** The Siderolabs ecosystem (bldr, kres, imager) is opinionated but consistent. Fighting it wastes time; embracing it gives you CI, reproducibility, and compatibility with upstream Talos for free.

## Common Pitfalls

### Pitfall 1: QEMU Slowdown on x86 Host

**What goes wrong:** ARM64 builds via QEMU on x86 hosts take 10-30x longer than native
**Why it happens:** Instruction translation overhead for compute-heavy kernel compilation
**How to avoid:** Use Apple Silicon Mac for local builds (native ARM64), or use GitHub's ARM64 runners for CI
**Warning signs:** Build times exceeding 30 minutes for overlay, 2+ hours for kernel

### Pitfall 2: Docker Desktop Resource Limits

**What goes wrong:** Builds fail or hang with OOM errors
**Why it happens:** Docker Desktop defaults to limited memory (2-4GB)
**How to avoid:** Settings > Resources > Memory: 8GB+ for kernel builds, 4GB minimum for overlays
**Warning signs:** "Killed" messages, buildkit exiting unexpectedly

### Pitfall 3: SD Card Write Errors

**What goes wrong:** Flashed image doesn't boot, random corruption
**Why it happens:** Not unmounting before write, bad SD card, interrupted write
**How to avoid:** Always unmount first, use high-quality SD cards (Samsung EVO, SanDisk Extreme), verify writes with balenaEtcher
**Warning signs:** dd completes but image doesn't boot, different behavior each flash

### Pitfall 4: Wrong Disk Target with dd

**What goes wrong:** Overwrites wrong disk, data loss
**Why it happens:** macOS disk numbering changes when devices are inserted/removed
**How to avoid:** ALWAYS run `diskutil list` immediately before dd, verify disk size matches SD card
**Warning signs:** Target disk is larger than SD card (you're about to wipe your internal drive)

### Pitfall 5: Boot Verification Without UART

**What goes wrong:** Board appears dead, no way to see what failed
**Why it happens:** User decided against UART adapter; early boot failures invisible
**How to avoid:** Watch for LED activity (SYS LED should blink), check HDMI for U-Boot/kernel output, ping network after expected boot time
**Warning signs:** No LED activity after 30 seconds = likely bootloader failure; LED blinks but no HDMI = kernel/DTB issue; HDMI shows kernel panic = driver/config issue

### Pitfall 6: Registry Push Without Authentication

**What goes wrong:** `make docker-*` fails with 401 Unauthorized
**Why it happens:** Not logged into Docker Hub before pushing
**How to avoid:** Run `docker login` before builds that push, set up credentials in CI secrets
**Warning signs:** "unauthorized: authentication required" errors

## Code Examples

Verified patterns from official sources and community projects:

### Docker buildx Setup (Apple Silicon)

```bash
# Source: Docker official docs
# Check current builder
docker buildx ls

# Create dedicated builder for multi-platform (optional, Desktop includes default)
docker buildx create --name sbc-builder --driver docker-container --use

# Verify ARM64 support (should show linux/arm64 in platforms)
docker buildx inspect --bootstrap
```

### Local Build Command

```bash
# Source: milas/talos-sbc-rk3588 Makefile
# Build overlay locally, output to _out directory
make local-talos-sbc-rk3588-mainline DEST=_out

# Build with custom registry (for testing push)
make docker-talos-sbc-rk3588-mainline \
  REGISTRY=docker.io \
  USERNAME=yourusername \
  PUSH=true
```

### SD Card Flash (macOS)

```bash
# Source: Community best practices
# Step 1: Identify SD card
diskutil list
# Look for external disk matching your SD card size (e.g., 32GB = /dev/disk2)

# Step 2: Unmount (not eject!)
diskutil unmountDisk /dev/disk2

# Step 3: Write image using raw device (rdisk) for speed
# bs=1m = 1MB block size, status=progress shows progress
sudo dd if=_out/metal-arm64.raw of=/dev/rdisk2 bs=1m status=progress

# Step 4: Sync and eject
sync
diskutil eject /dev/disk2
```

### GitHub Actions CI Skeleton

```yaml
# Source: milas/talos-sbc-rk3588 + Docker official docs
name: CI

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest  # Or self-hosted ARM64 runner
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git describe

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build and push
        run: |
          make docker-talos-sbc-rk3588-mainline \
            REGISTRY=docker.io \
            USERNAME=${{ vars.DOCKER_USERNAME }} \
            PUSH=${{ github.event_name != 'pull_request' }}
```

### Boot Verification Without UART

```bash
# Source: FriendlyELEC Wiki + practical experience

# After inserting SD card and powering on:

# 1. Watch LEDs (first 30 seconds)
#    - SYS LED should start blinking within 5-10 seconds (U-Boot running)
#    - Steady rapid blink = kernel booting
#    - No LED activity = bootloader failed, reflash

# 2. Watch HDMI (if connected)
#    - U-Boot logo/text should appear within 5 seconds
#    - Kernel boot messages follow
#    - Talos maintenance mode or login prompt = success

# 3. Ping network (after 60-90 seconds)
#    - If DHCP is configured, board should get IP
#    - Check router's DHCP leases for new device
#    - ping <ip-address> to verify

# 4. If boot fails
#    - Power off (hold power button or unplug)
#    - Eject SD card
#    - Reflash with known-good image or investigate
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| QEMU emulation for ARM64 | Native ARM64 runners | GitHub Jan 2025 | 10-22x faster CI builds |
| Docker Hub rate limits | ghcr.io for OSS | 2020+ | No anonymous pull limits |
| Manual Makefile maintenance | kres generation | 2023+ | Consistent, maintainable builds |
| `disk` device on macOS | `rdisk` raw device | Always | 20x faster flash speeds |

**Deprecated/outdated:**
- **Docker Machine:** Replaced by Docker Desktop with native VM
- **boot2docker:** Long deprecated, use Docker Desktop
- **Manual QEMU setup for ARM64:** Docker Desktop bundles QEMU automatically

## Open Questions

Things that couldn't be fully resolved:

1. **NanoPi M6 specific LED behavior**
   - What we know: SYS and LED1 are GPIO-controlled, can indicate boot status
   - What's unclear: Exact blink patterns for different boot stages (U-Boot vs kernel)
   - Recommendation: Document observed LED behavior during first successful boot

2. **HDMI output timing without UART**
   - What we know: HDMI supports 8K output, should show U-Boot/kernel
   - What's unclear: When exactly HDMI becomes active (BL31? U-Boot? kernel?)
   - Recommendation: Test with known-good Armbian image first to establish baseline

3. **Optimal Docker Desktop memory for kernel builds**
   - What we know: 4GB minimum, 8GB recommended
   - What's unclear: Exact requirements for full RK3588 kernel build
   - Recommendation: Start with 8GB, increase to 16GB if OOM occurs

4. **Docker Hub vs ghcr.io for overlay images**
   - User decided: Docker Hub for overlay images
   - What's unclear: Rate limit implications for public pulls
   - Recommendation: Use ghcr.io for build caching, Docker Hub for final releases

## Sources

### Primary (HIGH confidence)

- [Docker Multi-platform Builds](https://docs.docker.com/build/building/multi-platform/) - Official buildx documentation
- [Docker GitHub Actions Guide](https://docs.docker.com/guides/gha/) - CI integration patterns
- [siderolabs/bldr README](https://github.com/siderolabs/bldr/blob/main/README.md) - Build system documentation
- [siderolabs/kres Repository](https://github.com/siderolabs/kres) - Makefile generation
- [milas/talos-sbc-rk3588](https://github.com/milas/talos-sbc-rk3588) - Reference RK3588 overlay project
- [FriendlyELEC NanoPi M6 Wiki](https://wiki.friendlyelec.com/wiki/index.php/NanoPi_M6) - Hardware specifications, UART pinout, LED info

### Secondary (MEDIUM confidence)

- [Docker Layer Caching in GitHub Actions](https://www.blacksmith.sh/blog/cache-is-king-a-guide-for-docker-layer-caching-in-github-actions) - Cache strategies comparison
- [GitHub ARM64 Runners Announcement](https://linux-digest.com/unlocking-native-arm-builds-a-deep-dive-into-github-actions-new-free-arm64-linux-runners) - Native ARM64 CI availability
- [macOS dd Best Practices](https://radugin.com/posts/2025-05-04/disk-image-with-dd-on-macos/) - SD card flashing on macOS

### Tertiary (LOW confidence - verify during implementation)

- [Faster Multi-Platform Builds](https://www.docker.com/blog/faster-multi-platform-builds-dockerfile-cross-compilation-guide/) - Cross-compilation optimizations

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Official Docker docs, established Siderolabs tooling
- Architecture patterns: HIGH - Verified against milas project structure
- Pitfalls: MEDIUM - Some specific to NanoPi M6 hardware need validation

**Research date:** 2026-02-02
**Valid until:** 2026-03-02 (30 days - stable tooling, slow-moving ecosystem)

---

## Recommendations for Claude's Discretion Items

### Build Caching Strategy

**Recommendation:** Use Docker layer caching for local builds, registry cache for CI

**Local builds (Apple Silicon):**
- Docker Desktop manages local BuildKit cache automatically
- No additional configuration needed
- Cache persists across builds in `~/Library/Containers/com.docker.docker/`

**CI builds (GitHub Actions):**
- Use `type=registry` cache for best cross-run performance
- Registry cache avoids GitHub Actions cache size limits (10GB)
- Cache intermediate layers with `mode=max` for multi-stage builds

```yaml
# CI cache configuration
- name: Build with cache
  uses: docker/build-push-action@v5
  with:
    cache-from: type=registry,ref=docker.io/${{ vars.DOCKER_USERNAME }}/nanopi-m6:buildcache
    cache-to: type=registry,ref=docker.io/${{ vars.DOCKER_USERNAME }}/nanopi-m6:buildcache,mode=max
```

### Which Generated Files to Commit

**Recommendation:** Commit source configs, gitignore binaries

**COMMIT (source configs):**
- `.kres.yaml` - Build configuration source
- `Pkgfile` - Package definitions
- `pkg.yaml` files - Per-package build steps
- `installers/*/src/*.go` - Installer source code
- `profiles/*.yaml` - Profile definitions
- `hack/patches/*` - Source patches

**DO NOT COMMIT (generated/binary):**
- `Makefile` - Regenerate with `make rekres`
- `_out/` - Build outputs
- `*.raw`, `*.raw.xz` - Flashable images
- `.cache/` - Build cache

**Gitignore additions:**
```gitignore
# Build outputs
_out/
*.raw
*.raw.xz
*.tar

# Generated files (regenerate with make rekres)
# Makefile  # Consider committing for CI reproducibility
.dockerignore
.drone.yaml
.golangci.yml
```

**Note:** The milas project commits the generated Makefile for CI stability. This is acceptable if you regenerate with `make rekres` before committing changes to `.kres.yaml`.

### Documenting Failed Attempts

**Recommendation:** Document failures that provide learning value

**Document in `.planning/` or commit messages:**
- Configuration changes that caused boot failures
- Build flag combinations that didn't work
- SD card/hardware issues encountered

**Don't document:**
- Typos and obvious mistakes
- Transient network/CI failures
- Issues resolved within same session

**Format suggestion:**
```markdown
## Known Issues Log

### 2026-02-02: U-Boot DTB mismatch
**Symptom:** Board powers on, LED blinks once, then nothing
**Cause:** Using R6C DTB instead of M6-specific
**Fix:** Extract DTB from Armbian, not upstream U-Boot
```
